# react-ts-quickstart

## Vite 프로젝트에서 절대 경로를 사용하는 방법

Vite로 생성된 프로젝트에서 절대 경로를 사용하려면 약간의 설정이 필요함.

1. tsconfig.json에 아래의 내용을 추가

```json
{
    "compilerOptions": {
        "baseUrl": ".",
        "paths": { "@/*": ["./src/*"] },
        ...
    }
}
```

2. npm install path 명령어를 수행하여 path 패키지를 추가한 후 vite.config.ts 파일에 아래 내용 추가

```javascript
import path from "path";
export default defineConfig({
  resolve: {
    alias: [{ find: "@", replacement: path.resolve("src") }],
  },
});
```

이제부터는 절대 경로를 사용할 수 있습니다. App 컴포넌트를 임포트하는 코드를 절대 경로로 표현하면 다음과 같습니다.

```javascript
// import App from "./App";
// @가 src 디렉토리를 나타냅니다.
import App from "@/App";
```

## JSX 주의 사항

JSX(JavaScript XML)는 HTML처럼 보이지만 실제로는 자바스크립트 확장입니다. 쉽게 말해 JSX는 자바스크립트 코드로 변환되어 실행된다는 뜻입니다.
JSX의 사용이 필수는 아니지만 JSX는 UI를 표현하는데 적합해서 웹 디자이너나 웹 퍼블리셔들과 협업하기가 편리합니다. 그리고 JSX는 자바스크립트 코드이므로 자바스크립트 언어라는 의미가 변형되지 않으면서도 애플리케이션 화면의 구조를 시각화하여 표현할 수 있습니다. 이러한 장점으로 인해 대부분의 개발자가 JSX를 사용하고 있으므로 JSX를 사용하기를 권장합니다.

**1. 요소의 Attribute는 카멜 표기법을 준수해야 합니다.**

- JSX는 자바스크립트 언어이므로 대소문자를 구벼랍니다. 따라서 css-style과 같이 케밥 표기법을 사용하지 않습니다. 예를 들어 자바스크립트 코드에서는 onclick처럼 이벤트를 모두 소문자로 작성하지만 리액트에서는 onClick과 같이 새로운 단어가 연결되면 첫 글자를 대문자로 표기합니다.

> **파스칼 표기법**
> 첫 문자를 대문자로 표현하고 새로운 단어가 시작할 때마다 대문자로 시작합니다. 주로 Java, C#, C++과 같은 프로그래밍 언어에서 클래스 같은 타입을 선언할 때 사용합니다. 예) PascalCasing
> **카멜 표기법**
> 첫 문자를 소문자로 표현하고 새로운 단어가 시작할 때마다 대문자로 시작합니다. 마치 낙타의 등 모양처럼 보인다고 해서 이름 붙은 표기법입니다. 주로 객체, 변수, 인스턴스 등의 이름을 지정할 때 사용하는 표기법입니다. 예) camelCasing
> **케밥 표기법**
> 모두 소문자를 사용하며 새로운 단어가 시작할 때마다 하이픈(-) 기호를 붙입니다. 대소문자를 구별하지 않는 환경에서 주로 사용합니다. 예) kebob-casing
> **스네이크 표기법**
> 모두 소문자를 사용하며 새로운 단어가 시작할 때마다 언더스코어(\_) 기호를 붙입니다. 예) snake_casing

**2. 속성명이 DOM API 스펙에 기반을 두고 있습니다.**

- HTML에서는 class 속성을 사용하는데 JSX에서는 왜 className 속성을 사용할까요? HTML에서의 CSS클래스 지정 방법과 자바스크립트에서의 CSS 클래스 지정 방법을 비교해보면 그 이유를 알 수 있습니다,

```javascript
// HTML에서의 CSS 클래스 지정
<div id="a" class="test"></div>

// javascript 코드에서의 CSS 클래스 지정
document.getElementById('a').className = 'test';

// JSX에서의 정적 CSS 클래스 지정
<div id="a" className="test"></div>

// JSX에서의 동적 CSS 클래스 지정
let clsName = 'test';
...
<div id="a" className={clsName}></div>
```

- 앞의 코드를 살펴보면 HTML에서는 class라는 속성으로 CSS 클래스명을 지정하지만, 자바스크립트 코드에서는 className 속성으로 클래스명을 지정합니다. JSX는 HTML처럼 보이지만 실제로는 자바스크립트 코드이기 때문에 className 속성으로 사용해야만 합니다.

**3. 보간법{}을 사용할 때는 표현식을 사용해야 합니다.**

- {} 안에는 값, 메서드의 리턴값, 속성 등의 표현식을 작성할 수 있지만 문(statement)을 작성할 수는 없습니다. **{}는 무엇인가 데이터를 UI로 렌더링하려는 것이 목적이므로 반드시 값(리턴값)이 있어야 합니다.** 예를 들어 if문은 리턴값이 없으므로 사용할 수 없습니다. 대신에 다음과 같이 삼항 연산식은 리턴값이 있으므로 사용할 수 있습니다.

```javascript
// a가 true면 b를 리턴, false면 c를 리턴함
{
  a ? b : c;
}
```

for문도 리턴값이 없으므로 {}내부에 작성할 수 없습니다. 배열 데이터를 이용해 반복적으로 요소를 렌더링하려면 배열 객체의 map()과 같은 메서드를 사용하거나 미리 반복 렌더링한 결과 객체를 {}내부에 배치합니다.

**4. {}내에 보간된 HTML 문자열은 인코딩됩니다.**

- {}내부에 배치한 표현식에 의해 리턴되는 값이 문자열인경우, 모두 HTML 인코딩된다는 점을 주의해야 합니다.

```javascript
let msg = "<i>World</i>";
// 출력 결과: &lt;i&gt;World&lt;/igt;
```

- 브라우저 화면에서 <i></i>태그의 문자열이 그대로 출려됐습니다. 그 이유는 웹 애플리케이션에서 흔히 발생하는 XSS(Cross Site Scripting) 같은 공격에 대비하기 위해서`&lt;i&gt;`로 HTML 인코딩됐기 때문입니다.
- 만일 HTML마크업 형태의 값을 보간하려고 한다면 두 가지 방법을 사용할 수 있습니다. 첫 번째 방법은 dangerouslySetInnerHTML 특성을 사용하는 것입니다.

```html
<!-- {msg}를 대신하여 다음 코드를 적용합니다. -->
<span dangerouslySetInnerHTML="{{" __html: msg }} />
```

- 두 번째 방법은 JSX가 XSS 공격에 안전하므로 HTML 문자열 대신 JSX를 사용하는 것입니다.

```javascript
// let msg = '<i>World</i>';
let msg = <i>World</i>;
```

## 리액트 이벤트

- 리액트가 이벤트를 처리하는 방법은 HTML DOM에서 이벤트를 처리하는 방법과 조금 다릅니다.
- 리액트는 HTML DOM 이벤트를 추상화하여 여러 브라우저에서 동일한 특성(attribute)을 이용할 수 있도록 이벤트를 정규화 합니다.
- 또 성능 개선을 위해 모든 이벤트를 리액트 컴포넌트 트리가 렌더링되는 루트 DOM 컨테이너 요소에 연결하고 이벤트를 위임처리 합니다.
- 이벤트가 발생하면 리액트는 루트 DOM 컨테이너에서 적절한 컴포넌트 요소를 연결하여 실행합니다.

**주의점**

- 이벤트 핸들러를 지정할 때는 카멜 표기법 사용. ex) `onClick`
- 이벤트를 함수 또는 메서드와 연결할 때는 다음과 같이 {}보간법을 사용함.

```html
<!-- 함수 또는 메서드 호출 -->
<button onClick={func}>OK</button>
<!-- 익명 함수 호출 -->
<button onClick={ () => alert('hello') }>OK</button>
```

### 이벤트 적용 방법

**1. 이벤트 핸들러 함수를 정의하여 {}보간법을 이용해 외부 함수를 바인딩 함. 익명 함수도 가능**

```html
const eventHandler = () => {...};

<!-- JSX 내부에서 외부 함수 바인딩 -->
<input type="text" onChange={eventHandler} />

<!-- JSX 내부에서 익명 함수 바인딩 -->
<button onClick={ () => { ... } }>버튼</button>
```

**2. 이벤트 핸들러 함수의 첫 번째 인자를 이용해 이벤트 아규먼트 값을 이용함.**

```javascript
const eventHandler = (e: ChangeEvent<HTMLInputElement>) => {
  setValue(e.target.value);
};
```

### 이벤트 아규먼트의 정적 타입

리액트 이벤트 핸들러 함수에서의 이벤트 아규먼트는 브라우저의 종류와 관계없이 이벤트를 처리할 수 있도록 `SyntheticEvent<T>` 타입으로 추상화합니다. SyntheticEvent를 기반으로 확장된 다양한 Event 타입은 다음과 같습니다.

- SyntheticEvent
- KeyboardEvent
- ClipboardEvent
- FocusEvent
- TouchEvent
- AnimationEvent
- ChangeEvent
- CompositionEvent
- FormEvent
- MouseEvent
- WheelEvent
- DragEvent
- UIEvent
- TransitionEvent

모든 이벤트 타입을 기억할 필요 X. VSCode에서 `onChange`와 같이 작성 후 마우스 포인터를 올리면 툴팁을 통해 이벤트 타입 확인 가능.

### 리액트의 단방향 데이터 바인딩

리액트 애플리케이션은 상태(데이터)가 바뀌면 UI(화면)가 갱신되는 단방향 데이터 바인딩 구조입니다.
마치 엑셀에서 스프레드시트의 데이터가 바뀌면 데이터를 이용해 그린 엑셀 차트가 갱신되는 것과 유사합니다.

그런데 리액트는 양방향 데이터 바인딩을 지원하지 않으므로 UI에서 입력한 값이 상태에 반영되지 않습니다.
그래서 리액트는 UI에서 입력한 값을 상태에 반영하기 위해 리액트 이벤트 시스템을 이용합니다. 이벤트 핸들러 함수에서 상태를 변경하면 변경된 상태가 UI를 갱신시킵니다.

> State ➡ View ➡ Event ➡ setState() ➡ State

### 이벤트 핸들러와 상태 변경

이벤트 해들러 함수에서 상태를 변경할 때는 `useState()`를 호출해 `return`받은 setter 함수를 이용합니다.
setter 함수를 통해서 상태를 변경하는 기본적인 방법은 다음과 같습니다.

> setter([새로운 상태값])

주의할 점은 setter 함수는 비동기로 작동하기 때문에 이벤트 핸들러 함수 안에서 같은 상태를 여러 번 변경하면 문제가 발생할 수 있습니다.

불가피하게 같은 상태를 여러 번 변경해야 하는 경우에는 다음과 같이 함수를 이용해 return값으로 상태를 변경하도록 작성하면 됩니다.

```javascript
const increment = () => {
  setCount((count) => count + 1);
  setCount((count) => count + 1);
  setCount((count) => count + 1);
};

// count값이 3씩 증가함
```

### 제어 컴포넌트와 비제어 컴포넌트

컴포넌트 상태가 입력 필드를 제어하는지 아닌지에 따라 제어 컴포넌트와 비제어 컴포넌트로 구분합니다.

**제어 컴포넌트**
UI에서 입력 필드의 값이 상태(state)나 속성(props)에 의해 강하게 제어되는 컴포넌트임.
따라서 상태, 속성이 바뀌지 않는 한 입력값을 변경할 수 없음.
제어 컴포넌트에서 입력 필드의 값을 변경하려면 리액트의 이벤트 핸들러를 이용해 상태를 변경해야 함.

**비제어 컴포넌트**
상태, 속성에 의해 제어되지 않기 때문에 리액트 이벤트를 이용하지 않아도 사용자가 입력 필드의 값을 수정할 수 있음.
하지만 이때 수정한 값으로는 상태가 변경되지 않기 때문에 입력값을 획득하기 위해서 HTML DOM 요소에 직접 접근해야 함.

그러나 리액트는 가상DOM 기반이므로 브라우저의 HTML DOM에 직접 접근하는 것은 비효율적임. 꼭 필요한 경우이거나 성능 이슈가 발생할 가능성이 없는 컴포넌트에서만 사용할 것을 권장함.

비제어 컴포넌트는 비록 상태나 속성이 입력 필드를 제어하지는 않지만 초깃값을 부여할 수 있음.
초깃값을 부여하는 속성은 모두 default~로 시작함.
`value`속성이라면 `defaultValue`, `checked` 속성이라면 `defaultChecked`와 같이 명명됨.

> 참고예제
> event-test\src\App2.tsx
> event-test\src\App3.tsx

### 컨테이너 컴포넌트와 표현 컴포넌트
**컨테이너 컴포넌트(container component)**
컨테이너 컴포넌트는 상태와 상태 변경, 비즈니스 로직을 처리하는 연산 기능이 있으며 UI와 스타일 정보는 포함하지 않고 단순히 자식 컴포넌트를 조합하도록 작성합니다.

**표현 컴포넌트(presentational component)**
표현 컴포넌트는 부모 컴포넌트로부터  속성(props)을 전달받아 UI를 랜더링하는 기능을 수행합니다. 연산과 로직으로부터 UI를 분리해서 작성하므로 재사용성이 높습니다.
표현 컴포넌트는 자신의 상태를 가지지 않지만 수명 주기 관리가 필요하지 않은 상태라면 표현 컴포넌트 내부에 상태를 가질 수도 있습니다.
***
가능하다면 상태는 주요 거점의 위치에 작성하는 컨테이너 컴포넌트가 관리하도록 하고, 나머지는 표현 컴포넌트를 이용해 UI 기능을 구현하는 것이 좋습니다.
각각의 컴포넌트가 모두 상태를 가지면 어느 한 컴포넌트에서 이벤트가 발생했을 때 여러 컴포넌트의 상태를 변경해야 할 수도 있습니다. 그러면 상태의 변경을 추적하기가 어려워서 디버깅이 까다로워 집니다.
하지만 주요 거점의 컴포넌트를 컨테이너 컴포넌트로 작성하고 나머지를 표현 컴포넌트로 작성하면 이러한 문제가 발생하지 않습니다.
***
컨테이너 컴포넌트 중심으로 컴포넌트 구조를 설계하면 상태와 변경 로직은 모두 컨테이너 컴포넌트에 집중됩니다.
따라서 **컨테이너 컴포넌트에서의 상태 변경만을 추적하면 그 하위 컴포넌트의 UI가 어떻게 바뀔지를 예측할 수 있습니다. 즉, 상태 변경 추적이 용이해지고 그에 따라 디버깅도 좀 더 쉽게 할 수 있습니다.**

**상태를 변경하는 함수와 메서드는 상태를 보유한 컴포넌트에서 작성되어야 합니다.** 그러므로 자식 컴포넌트에 **상태와 함께 상태를 변경하는 함수도 속성으로 전달합니다.**
자식 컴포넌트에서 이벤트가 발생하면 속성을 통해서 전달받은 함수를 호출하여 컨테이너 컴포넌트의 상태를 변경합니다.
이러한 함수와 메서드를 콜백 함수(메서드)라고 부릅니다.

#### [정리]
- **부모에서 자식으로의 정보 전달 방법**
속성(props)를 이용해서 정보를 전달
- **자식에서 부모로의 정보 전달 방법**
속성을 이용해 부모 컴포넌트의 함수(메서드)를 자식 컴포넌트로 전달하고, 자식 컴포넌트에서 이벤트가 발생하면 해당 함수를 호출